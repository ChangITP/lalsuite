#!/usr/bin/python
#
# Copyright (C) 2012 Matthew West
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                  Preamble
#
# =============================================================================
#

import math
import sys
from optparse import OptionParser

from glue import lal
from glue.ligolw.utils import ligolw_add
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils

from pylal import git_version

__author__ = "Matthew West <matthew.west@ligo.org>"
__version__ = "git id %s" % git_version.id
__date__ = git_version.date


#
# =============================================================================
#
#                                Command Line
#
# =============================================================================
#


def parse_command_line():
	"""
	Parse the command line, return an options object and a lal.Cache of inspiral files
	"""
	parser = OptionParser(
		version = "Name: %%prog\n%s" % git_version.verbose_msg,
		usage = "%prog [options]",
		description = ""
		)
	#
	parser.add_option("-i", "--inspiral-cache", metavar = "name", type="string", default=None, \
		help = "Get input inspiral files from the LAL cache named filename. Required." 
		)
	parser.add_option("-f", "--tmplt-file", metavar = "name", type="string", default=None, \
		help = "The tmpltbank file. Required"
		)
	parser.add_option("-n", "--tmplt-num", metavar = "int", type="int", default=None, \
		help = "Define the desired template id number. Required"
		)
	parser.add_option("-t", "--usertag", metavar = "tag", type="string", default="FULL_DATA", \
		help = ""
		)
	parser.add_option("-s", "--gps-start-time", metavar = "int", type="int", \
		help = "Start time, in gps seconds, of the experiment being performed. Required."
		)
	parser.add_option("-e","--gps-end-time", metavar = "int", type="int",
		help = "End time, in gps seconds, of the experiment being performed. Required."
		)
	parser.add_option("-v", "--verbose", action = "store_true", default=False, \
		help = "Be verbose."
		)
	options, arguments =  parser.parse_args()

	if not options.gps_start_time or not options.gps_end_time:
		raise ValueError, "must specify --gps-start-time and --gps-end-time" 
	if not options.inspiral_cache:
		raise ValueError, "must specify --inspiral-cache"
	if not options.tmplt_file or not (options.tmplt_num >= 0):
		raise ValueError, "must specify both --tmplt-file and --tmplt-num" 

	return options

#
# =============================================================================
#
#                                    Main
#
# =============================================================================
#


#
# Command line
#

opts = parse_command_line()

# create cache of desired inspiral files
file_sieve = 'INSPIRAL_FIRST_' + opts.usertag
ihope_cache = lal.Cache([lal.CacheEntry(line) for line in file(opts.inspiral_cache)])
inspiral_cache = ihope_cache.sieve(description = file_sieve, exact_match = True)

# optimize table for speed and memory usage
lsctables.SnglInspiralTable.next_id = lsctables.SnglInspiralID(1)
lsctables.SnglInspiralTable.updateKeyMapping = lsctables.table.Table.updateKeyMapping
lsctables.table.RowBuilder = lsctables.table.InterningRowBuilder

# get desired template parameters
tmplt_xmldoc = utils.load_filename(opts.tmplt_file, opts.verbose)
tmplt_tbl = table.get_table(tmplt_xmldoc, lsctables.SnglInspiralTable.tableName)
if opts.tmplt_num >= len(tmplt_tbl):
	raise ValueError, "The given template number: %d is too large for this bank" % opts.tmplt_num
mchirp = tmplt_tbl.getColumnByName("mchirp")[opts.tmplt_num]
eta = tmplt_tbl.getColumnByName("eta")[opts.tmplt_num]

# loop over the files in the cache
xmldoc = ligolw.Document()
for n, file in enumerate(inspiral_cache):
	if opts.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(inspiral_cache)),
	utils.load_url(file.url, verbose = opts.verbose, xmldoc = xmldoc, contenthandler = None)
	# Document merge
	if opts.verbose:
		print >>sys.stderr, "merging elements ..."
	ligolw_add.merge_ligolws(xmldoc)
	ligolw_add.merge_compatible_tables(xmldoc)
	# Remove triggers not matching template parameters
	sngl_insp_tbl = table.get_table(xmldoc, lsctables.SnglInspiralTable.tableName)
	max_idx = len(sngl_insp_tbl) - 1
	for idx, row in enumerate( reversed(sngl_insp_tbl) ):
		if abs(row.mchirp/mchirp - 1) > 1e-6 or abs(row.eta/eta - 1) > 1e-6:
			del sngl_insp_tbl[max_idx - idx]

ligolw_add.reassign_ids(xmldoc, verbose = opts.verbose)

# Define the output filename
ifos = ''.join( set(file.observatory for file in inspiral_cache) )
tmplt_id = 'TMPLT_%%0%dd' % int(math.log10(len(tmplt_tbl))+1)
tmplt_id = tmplt_id % opts.tmplt_num
duration = opts.gps_end_time - opts.gps_start_time
output_filename = '-'.join([ifos, file_sieve, tmplt_id, str(opts.gps_start_time), str(duration)]) + '.xml.gz'

#
# Write back to disk, and clean up.
#
utils.write_filename(xmldoc, output_filename, opts.verbose, gz = output_filename.endswith(".gz"))
