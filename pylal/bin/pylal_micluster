#!/usr/bin/env python

# Copyright (C) 2012 Ian W. Harry, Duncan M. Macleod
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Cluster MultiInspiral events generated by the CBC coherent (PTF) analysis.
"""

# =============================================================================
# Preamble
# =============================================================================

from __future__ import division
import os
import sys
import time
import optparse
import numpy
import itertools

from lal import GPSTimeNow

from pylal import git_version, llwapp, MultiInspiralUtils

from glue import lal as cache
from glue.ligolw import ligolw, lsctable, table
from glue.ligolw import utils as ligolw_utils
from glue.ligolw.utils import process as ligolw_process
from glue.ligolw.utils import search_summary as ligolw_search_summary
            
__author__ = ("Ian W. Harry <ian.harry@astro.cf.ac.uk>, "
              "Duncan M. Macleod <duncan.macleod@ligo.org>")
__version__ = git_version.id
__date__ = git_version.date

# set up timer
start = int(time.time()*10**6)
elapsed_time = lambda: int(time.time()*10**6-start)


# =============================================================================
# Parse command line
# =============================================================================

def parse_command_line():
    """Parse command line arguments, performing sanity checks
    """
    epilog = "For help, just ask.ligo.org"
    # setup parser
    parser = optparse.OptionParser(description=__doc__, epilog=epilog,
                                   formatter=optparse.IndentedHelpFormatter(4))
    parser.add_option("-v", "--verbose", action="store_true", default=False,
                      help="verbose output, default: %default")
    parser.add_option("-V", "--version", action="version",
                      help="show program's version number and exit")
    parser.version = __version__

    # input options
    inputopts = optparse.OptionGroup(parser, "Input options")
    inputopts.add_option("-t", "--trig-file", action="append", type="string",
                         default=[],
                         help="Path to xml file containing MultiInspiralTable")
    inputopts.add_option("-c", "--cache-file", action="store", type="string",
                         default=None,
                         help=("Path to LAL-format cache file containing "
                               "paths to xml files containing "
                               "MultiInspiralTables"))
    # output options
    outputopts = optparse.OptionGroup(parser, "Output options")
    outputopts.add_option("-o", "--output-file", action="store",
                          type="string", help="File path for output xml.")

    # clustering options
    clusteropts = optparse.OptionGroup(parser, "Clustering options")
    clusteropts.add_option("-W", "--time-window", action="store",
                           type="float", default=None,
                           help="The cluster time window")

    (opts,args) = parser.parse_args()

    if not opts.trig_file and not opts.cache_file:
        parser.error("Must provide either --trig-file or --cache-file.")

    if not opts.time_window or opts.time_window <= 0:
        parser.error("A positive --time-window must be given.")

    return opts, args


# =============================================================================
# Cluster MultiInspiralTable
# =============================================================================

def cluster_multi_inspiral(mi_table, timeWindow):
    """Cluster a LIGOLw MultiInspiralTable by SNR according to a given
    clustering timeWindow.
    """
    # get data
    end_time = numpy.asarray(mi_table.get_end()).astype(float)
    snr = numpy.asarray(mi_table.get_column("snr"))

    # get times
    start = round(end_time.min())
    end = round(end_time.max()+1)

    #
    # bin all triggers in time
    #

    # generate bins
    numBins  = int((end-start)//timeWindow + 1) 
    timeBins = []
    loudestTrigSNR = numpy.zeros(numBins)
    loudestTrigTime = numpy.zeros(numBins)
    for n in range(numBins):
        timeBins.append([])

    # bin triggers
    for i,(t,s) in enumerate(itertools.izip(end_time, snr)):
        bin = int(float(t-start)//timeWindow)
        timeBins[bin].append(i)
        if not loudestTrigSNR[bin]:
            loudestTrigSNR[bin] = s
            loudestTrigTime[bin] = t
        else:
            if loudestTrigSNR[bin] < s:
                loudestTrigSNR[bin] = s
                loudestTrigTime[bin] = t

    #
    # cluster bins
    #

    clstTrigs = table.new_from_template(mi_table)

    # loop over all bins
    for i,bin in enumerate(timeBins):
        if len(bin)<1:
            continue
        first = i==0
        last = (i==numBins-1)
 
        prev = i-1
        next_ = i+1
        check_prev = (not first and len(timeBins[prev]) > 0)
        check_next = (not last and len(timeBins[next_]) > 0)

        # loop all triggers in bin
        for idx in bin:
            # search this trigger's own bin
            s = snr[idx]
            if s < loudestTrigSNR[i]:
                continue

            t = end_time[idx]

            # trigger was loudest in it's bin, search loudest event
            # in previous bin
            if (check_prev and (t - loudestTrigTime[prev]) < timeWindow and
                    s < loudestTrigSNR[prev]):
                continue

            # Same for the next_ bin
            if (check_next and (loudestTrigTime[next_] - t) < timeWindow and
                    s < loudestTrigSNR[next_]):
                continue
 
            loudest=True

            # trigger was loudest in it's bin, search previous bin
            if check_prev and not (t - loudestTrigTime[prev]) < timeWindow:
                for idx2 in timeBins[prev]:
                    t2 = end_time[idx2]
                    if (t - end_time[idx2]) < timeWindow and s < snr[idx2]:
                        loudest = False
                        break
            if not loudest:
                continue

            # if still loudest, check the next_ bin
            if check_next and not (loudestTrigTime[next_] - t) < timeWindow:
                for idx2 in timeBins[next_]:
                    if (end_time[idx2] - t) < timeWindow and s < snr[idx2]:
                        loudest = False
                        break
            if not loudest:
                continue
           
            # this was the loudest trigger in its vicinity,
            # keep it and move to the next_ bin
            clstTrigs.append(mi_table[idx])
            break

    return clstTrigs


# =============================================================================
# Run from command line
# =============================================================================

if __name__=='__main__':

    # parse command line
    opts, args = parse_command_line()
    verbose = opts.verbose

    outfile = opts.output_file

    #
    # setup output
    #

    # generate LIGOLw document
    outxml = ligolw.Document()
    outxml.appendChild(ligolw.LIGO_LW())

    # append our process
    process = ligolw_process.append_process(outxml, program=__file__,
                                            version=__version__)
    options = [("--time-window", opts.time_window), ("--output-file", outfile)] 
    if opts.cache_file:
        options.append(("--cache-file", opts.cache_file))
    for fp in opts.trig_file:
        options.append(("--trig-file", opts.trig_file))
    for key,val in options:
        ligolw_process.append_process_params(outxml, process,
                                             [(key, "lstring", val)])

    # 
    # load triggers
    #

    # list files
    trig_cache = cache.Cache()
    if opts.trig_file:
        trig_cache.extend(map(cache.CacheEntry.from_T050017, opts.trig_file))
    if opts.cache_file:
        trig_cache.extend(cache.Cache.fromfile(open(opts.cache_file, "r")))
    trig_cache.sort(key=lambda e: e.segment[0])

    # load triggers with only those columns the parent job actually wrote
    N = len(trig_cache)
    if verbose:
        sys.stdout.write("Loading triggers from %d files...     " % N)
        sys.stdout.flush()
    trig_table = None
    for i,fp in enumerate(trig_cache.pfnlist()):
        xmldoc = ligolw_utils.load_filename(fp, gz=fp.endswith("gz"))
        try:
            mi_table = table.get_table(xmldoc,
                                       lsctables.MultiInspiralTable.tableName)
        except ValueError:
            sys.stderr.write("\nwarning: failed to read %s.\n" % fp)
            sys.stdout.write("Loading triggers from %d files...  %.2d%%"
                             % (N, int(100*(i)/N)))
            sys.stdout.flush()
            continue
        if not trig_table and len(mi_table) > 0:
            columns = [slot for slot in mi_table[0].__slots__ if
                       hasattr(mi_table[0], slot)]
            lsctables.MultiInspiralTable.loadcolumns = columns
            trig_table = lsctables.New(lsctables.MultiInspiralTable,
                                       columns=columns)
        
        trig_table.extend(mi_table)
        if verbose:
            sys.stdout.write("\b\b\b%.2d%%" % (int(100*(i+1)/N)))
            sys.stdout.flush()
  
    if verbose:
        sys.stdout.write("\n%d triggers found at %d.\n"\
                         % (len(trig_table), elapsed_time()))

    #
    # cluster the triggers
    #

    cluster_table = cluster_multi_inspiral(trig_table, opts.time_window)
    snr = cluster_table.get_column("snr")

    if verbose:
        sys.stdout.write("%d triggers remaining at %d.\n"\
                         % (len(cluster_table), elapsed_time()))

    #
    # write the clusters to file
    #

    outxml.childNodes[-1].appendChild(cluster_table)
    outxml.childNodes[-1].appendChild(
        lsctables.New(lsctables.SearchSummaryTable))
    ligolw_search_summary.append_search_summary(outxml, process)
    process.end_time = GPSTimeNow().gpsSeconds
    ligolw_utils.write_filename(outxml, outfile, gz=outfile.endswith(".gz"),
                                verbose=verbose)
    if verbose:
        sys.stdout.write("Done at %d.\n" % (elapsed_time()))
