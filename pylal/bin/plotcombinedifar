#!/usr/bin/python

__author__ = "Collin Capano <cdcapano@physics.syr.edu>"
__version__ = "$Revision$"
__date__ = "$Date$"
__name__ = "plotcombinedifar"
__Id__ = "$Id$"

import sys
import os
from optparse import *
import re
import exceptions
import glob
from types import * #!!!what does this do?

from glue import lal
from glue import segments #!!!do I need this?
from glue import segmentsUtils #!!!do I need this?
from glue.ligolw import ligolw 
from glue.ligolw import table as tab #!!!why as tab?
from glue.ligolw import lsctables
from glue.ligolw import utils
import glue.iterutils
from pylal import CoincInspiralUtils
from pylal import SnglInspiralUtils
from pylal import InspiralUtils
from numpy import histogram

import itertools
import numpy
import operator
import matplotlib.mlab as mlab

usage =  """
"""
# ============================================================================
# def poly_between; needed if using older version of matplotlib
def poly_between(x, ylower, yupper):
    """
    given a sequence of x, ylower and yupper, return the polygon that
    fills the regions between them.  ylower or yupper can be scalar or
    iterable.  If they are iterable, they must be equal in length to x

    return value is x, y arrays for use with Axes.fill
    """
    Nx = len(x)
    if not iterable(ylower):
      ylower = ylower*numpy.ones(Nx)

    if not iterable(yupper):
      yupper = yupper*numpy.ones(Nx)

    x = numpy.concatenate( (x,x[::-1]) )
    y = numpy.concatenate( (yupper, ylower[::-1]) )
    return x,y
#  End poly_between ==========================================================
# ============================================================================
# Set options: --glob or --cache-file and --output-path are required

def parse_command_line():
  """
  Parser function dedicated
  """

  parser = OptionParser( usage = usage, version = "%prog CVS $Id$ " )
  # following are related to file input and output naming
  parser.add_option( "-g", "--glob", action = "store", type = "string", \
        default = None, metavar = " GLOB", \
        help = "glob of CORSE files to read" )
  parser.add_option( "-I", "--cache-file", \
        help = "read CORSE file names from cache input file" )
  parser.add_option( "-P", "--output-path", action = "store", type = "string", \
        default = "", metavar = "PATH", \
        help = "path where the figures should be stored" )
  parser.add_option( "-O", "--enable-output", action = "store_true", \
        default =  False, metavar = "OUTPUT", \
        help = "enable the generation of html and cache documents" )
  parser.add_option( "-s", "--show-plot", action = "store_true", default = False, \
        help = "display the plots on the terminal" )
  parser.add_option( "-v", "--verbose", action = "store_true", default = False, \
        help = "print information to stdout" )
  # following (gps-start/stop-time, ifo-times, ifo-tag, user-tag) are options
  # required by InspiralUtils to generate a file name. They are only used for
  # file naming. they aren't used in any calculations in the plot, so they are
  # all optional.
  parser.add_option( "", "--gps-start-time", action = "store", type = "int", \
        default = None, metavar = "GPSSTARTTIME", \
        help = "gps start time used in the figure and output file names" )
  parser.add_option( "", "--gps-end-time", action = "store", type = "int", \
        default = None, metavar = "GSPENDTIME", \
        help = "gps end time used in the figure and output file names" )
  parser.add_option( "", "--ifo-times", action = "store", default = None, metavar = "IFOS", \
        help = "puts the ifo times for which the plots were made into output file name." )
  parser.add_option( "", "--ifo-tag", action = "store", type = "string", \
        default = None, metavar = "IFOTAG", \
        help = "the ifo tag used in the name of the figure (e.g. SECOND_H1H2L1)" )
  parser.add_option( "-u", "--user-tag", action = "store", type = "string", \
        default = None, metavar = "USERTAG", \
        help = "user tag used in the name of the figures" )
  # following are ifar plot specific options
  parser.add_option( "", "--far-time-correction", action = "store", type = "float", \
        default = None, metavar = "T_COR", \
        help = "zero-lag time correction for FAR: FAR -> T_COR*FAR " + \
        "(for use when FAR calculated with all_data and need exclude_play " + \
        "or playground_only FAR)" )
  parser.add_option( "", "--t-correct-num", action= "store", type= "string", \
        default = None, metavar= "T_COR_NUM", \
        help = "coire summary file that contains the amount of analyzed time " + \
        "for the data-type you need to generate a correction factor for. " + \
        "Requires denominator file; precludes far-time-correction option." )
  parser.add_option( "", "--t-correct-denom", action = "store", type= "string", \
        default = None, metavar = "T_COR_DENOM", \
        help="coire summary file that contains the amount of all_data analyzed time. " + \
        "Dividing the value in the numerator file by this gives the " + \
        "far-time-correction factor as opposed to manually specifying. " + \
        "Requires numerator file; precludes far-time-correction option." )
  parser.add_option( "", "--min-ifar", action = "store", type = "float", \
        default = None, metavar = "MIN_IFAR", \
        help = "the minimum IFAR to plot" )
  parser.add_option( "", "--max-ifar", action = "store", type = "float", \
        default = None, metavar = "MAX_IFAR", \
        help = "the maximum IFAR to plot" )
  parser.add_option( "-a", "--ifar-dist", action = "store_true", default = False, \
        help = "plot a cumulative histogram of IFAR normalized in terms of a year" )
  parser.add_option( "-b", "--ifan-dist", action = "store_true", default = False, \
        help = "plot a cumulative histogram of IFAR*analysis time (the " + \
        "inverse false alarm number). This generates ifar plots as they " + \
        "were in the first year analysis." )
  parser.add_option( "-c", "--snr-ifar", action = "store_true", default = False, \
        help = "plot effective snr vs time-normalized ifar" )
  parser.add_option( "", "--show-min-bkg-ifar", action = "store_true", default = False, \
        help = "put a vertical line indicating where the background begins for some " + \
        "category. Requires num-slides option and a corse summary file with " + \
        "the same name and location as the input file with file extension .txt " + \
        "as opposed to .xml.gz"  )
  parser.add_option( "", "--show-max-bkg-ifar", action = "store_true", default = False, \
        help = "put a vertical line indicating where the background ends for some " + \
        "category. Requires num-slides option." )
  parser.add_option( "", "--num-slides", action = "store", default = None, \
        help = "Number of time slides performed. Only needed if using " + \
        "show min/max bkg ifar options." )
  parser.add_option( "", "--make-uncombined-plot", action = "store_true", default = False, \
        help = "make an uncombined plot of however many categories there are" )
  parser.add_option("", "--combine-ifan", action = "store_true", default = False, \
        help = "Combine IFANs from different experiments into one cum. hist." )
  parser.add_option("", "--combine-ifar-n-kink-bkg", action = "store_true", default = False, \
        help = "Combine IFARs from different experiments and kink the background" )
   
  (options,args) = parser.parse_args()

  #check if required options specified and for self-consistency
  if not options.glob or options.cache_file:
    raise ValueError, "--glob or --cache-file must be specified"
  if not options.output_path:
    raise ValueError, "--output-path must be specified"
  if options.t_correct_num and not options.t_correct_denom:
    raise ValueError, "--t-correct-num requires --t-correct-denom."
  if options.t_correct_denom and not options.t_correct_num:
    raise ValueError, "--t-correct-denom requires --t-correct-num."
  if options.t_correct_num and options.far_time_correction:
    raise ValueError, "If using --t-correct files, cannot use --far-time-correction."
  if options.show_min_bkg_ifar and not options.num_slides:
    raise ValueError, "--show-min-bkg-ifar requires --num-slides"
  if options.show_max_bkg_ifar and not options.num_slides:
    raise ValueError, "--show-max-bkg-ifar requires --num-slides"

  return options, sys.argv[1:]

# ============= End parse_command_line =======================================

# ============================================================================
# Initialization: get arguments and input files; store to tables

# parse command line
opts, args = parse_command_line()
# Change to Agg back-end if show() will not be called 
# thus avoiding display problem
if not opts.show_plot:
  import matplotlib
  matplotlib.use('Agg')
from pylab import *
from pylal import viz
from numpy import histogram
rc('text', usetex=True)

# set InspiralUtils options for file and plot naming
opts = InspiralUtils.initialise( opts, __name__, __version__ )
# set the proper color code and symbols
colors = InspiralUtils.colors
plotsymbols = ['r+','bx','ko','g1']
hanfordsym = ['b+','bx','r1']
addsym = ['k+','kx','k1']
figure_number = 0 # used for the figure label (showplot)
fnameList = [] # used for the html cache file
tagList = [] # ditto

# get input files
corsefiles = []
if opts.glob is not None:
  for gl in opts.glob.split(" "):
    corsefiles.extend(glob.glob(gl))
#elif opts.cache_file is not None:
  #!!! not sure what to do here
if not corsefiles:
  print >> stderr, "No corse files could be found. Check input args."
  sys.exit(1)

# if combining experiments or calculating FAR, need number of bkg coinc. and 
# time analyzed; this info is in the relevant corse summary files.
# These are found using the corsefiles list; assumption is that summary file
# has same name and location as the corse file, but has file extenstion .txt
if opts.show_min_bkg_ifar or opts.ifar_dist or opts.snr_ifar or opts.combine_ifan:
  # save num. bkg coincs and analyzed time to relevant dict. referenced by
  # corse file name
  NbkgCoinc = {}
  AnTime = {}
  for file in corsefiles:
    summfile = glob.glob(file.rstrip('.xml.gz') + '.txt')
    # check if corse file has a corresponding summary file
    if not summfile:
      print >>sys.stderr, "The file: %s does not have a summary file." %(file)
      sys.exit(1)
    # get needed info from summary file
    thisfile = open(summfile[0], 'r')
    for line in thisfile:
      if line.startswith( 'number of reconstructed slide coincidences:' ):
        NbkgCoinc[file] = float( line.split()[5] )
      elif line.startswith( 'amount of time analysed for triggers' ):
        time = float( line.split()[6] ) + float( line.split()[8] ) #sec + ns
        AnTime[file] = time / 31556925.9936 #divide by num of secs in a year
    thisfile.close()

# set statistic arg for the coincTable to far
coincStat = CoincInspiralUtils.coincStatistic("far")

# store coinc triggers to a CoincInspiralTable; this has to be done by first
# reading in the SnglInspiralTable, then constructing a coincident table from
# it. Since will need info from each file spearately (e.g., if normalizing by
# time, each FAN will need to be divided by the time analyzed for that corse
# file) am saving each coincTable to a dictionary of coinc tables
# referenced by the corresponding file name
coincT = {}
for thisfile in corsefiles:
  insptrigs = SnglInspiralUtils.ReadSnglInspiralFromFiles( [thisfile] )
  coincT[ thisfile ] = CoincInspiralUtils.coincInspiralTable( insptrigs, coincStat )
  coincT[ thisfile ].sort() # sort by descending FAN

# ============================================================================
# ============================================================================
# Apply necessary algorithims

if opts.combine_ifan:
  maxFANs = [] # for storing max FAN of bkg
  FANc = [] # for storing the combined FANs of foreground
  for thisfile in corsefiles:
    maxFANs.append( NbkgCoinc[thisfile]/(2*float(opts.num_slides)) )
    if coincT[thisfile].sngl_table: # if have foreground trigs
      for coinc in coincT[thisfile]:
        FANc.append( coinc.stat )
  FANc.sort(reverse=True) # order from weakest to strongest
  maxFANs.sort(reverse=True)
  # following works by starting from highest fan values and moving down (like
  # moving left to right on an IFAN plot)
  for ii in range(0,len(FANc)):
    for jj in range(1, len(maxFANs)): # cycle through bkg fans, skipping first one
      if FANc[ii] > maxFANs[jj]: # find the largest bkg fan < this foreground fan
        FANc[ii] = FANc[ii] * (jj) # multiply by number of active categories
        for kk in range(jj, len(maxFANs)):
          FANc[ii] = FANc[ii] + maxFANs[kk] # add bkg fans of inactive categories
        break # go to next fan in FANc
      elif jj == len(maxFANs)-1: # all categories active
        FANc[ii] = FANc[ii] * len(maxFANs)

# ============================================================================
# ============================================================================
# Make plots
colors = itertools.cycle(('b', 'g', 'r', 'c', 'm', 'k'))
symbols = itertools.cycle(( '--', ':', '-.' ))

if opts.make_uncombined_plot:
  if opts.ifan_dist:
    figure(figure_number)
    figure_number += 1
    xmin = numpy.inf
    xmax = float(opts.num_slides)*2.2
    ymin = 0.8
    ymax = 0
    for thisfile, lnsymbol in zip(corsefiles,symbols):
      if coincT[thisfile].sngl_table: # if have foreground trigs
        IFAN = []
        for coinc in coincT[thisfile]:
          if coinc.stat == 0: # set IFAN to maximum IFAN, which is the num. of slides
            IFAN.append( float(opts.num_slides)*2 )
          else:
            IFAN.append( 1./coinc.stat )
        IFAN = array(IFAN) # turn into a matplotlib array
        # generate cumnum array (the y-axis in the plot)
        cumnum = []
        for ii in range(len(IFAN)):
          cumnum.append( len( (IFAN>=IFAN[ii]).nonzero()[0] ))
        # set colors and symbos and plot IFAN for this category;
        # note that assuming the ifos are all the same in that file
        coinc_ifos = coincT[thisfile][0].get_ifos()[0]
        if coinc_ifos == 'H1L1':
          color = 'g'
        elif coinc_ifos == 'H2L1':
          color = 'r'
        elif coinc_ifos == 'H1H2L1':
          color = 'c'
        # set mass bin symbols
        mass = thisfile.split("/")[len(thisfile.split("/"))-2]
        if mass == 'mchirp_2_8':
          symbol = '^'
          lbl = coinc_ifos + " low-mass"
        elif mass == 'mchirp_8_17':
          symbol = 'o'
          lbl = coinc_ifos + " medium-mass"
        elif mass == 'mchirp_17_35':
          symbol = 'D'
          lbl = coinc_ifos + " high-mass"
        loglog( IFAN, cumnum, color+symbol, markerfacecolor=color,
                  markeredgecolor=color, alpha=0.65, 
                  label=lbl)
        hold(True)
        if xmin > IFAN[0]: # reset xmin
          xmin = IFAN[0]
        if ymax < cumnum[0]: # reset max
          ymax = cumnum[0]
      else:
        warn_msg = "File %s has no foreground triggers" %(thisfile)
        print >> sys.stdout, warn_msg
        if opts.show_min_bkg_ifar or opts.show_max_bkg_ifar:
          color = 'm' # for background lines
          if ymax == 0: ymax = 100
      # end if have foreground trigs
      # plot min bkg lines
      if opts.show_min_bkg_ifar:
        xminbkg = 2*float(opts.num_slides) / NbkgCoinc[thisfile]
        loglog( [xminbkg,xminbkg], [ymin,ymax*1.2], color, linestyle=lnsymbol,
                linewidth=2 )
        xmin = xminbkg
    # end loop over coinc tables
    # set xmin and ymax to be slightly smaller/larger
    xmin = xmin * 0.8
    ymax = ymax * 1.2
    # plot background
    xbkg = numpy.logspace( -4, 2, num=100, endpoint=True, base=10.0 )
    ybkg = 1./xbkg
    loglog( xbkg, ybkg, 'k--', linewidth=2, label='Background' )
    # plot error
    bkgplus = ybkg + sqrt(ybkg)
    bkgminus = ybkg - sqrt(ybkg)
    bkgminus = where( bkgminus<=0, 1e-5, bkgminus ) # prevent (-) values
    xs, ys = poly_between( xbkg, bkgminus, bkgplus )
    fill( xs, ys, facecolor='y', alpha=0.2, label='$N^{1/2}$ errors' )
    # plot max bkg line (note that this is only approx.
    if opts.show_max_bkg_ifar:
      xmaxbkg = 2*float(opts.num_slides)
      loglog( [xmaxbkg,xmaxbkg], [ymin,ymax*1.2], color='k', linestyle='-',
        linewidth=2, alpha=0.6 )
    xlim(xmin,xmax)
    ylim(ymin,ymax)
    xlabel( r"Inverse False Alarm Number", size='x-large' )
    ylabel( r"Cumulative \#", size='x-large' )
    legend()
    if opts.enable_output is True:
      name = "cumhist_ifan"
      text = "Cumulative Histogram of IFAN distribution"
      fname = InspiralUtils.set_figure_name(opts, name)
      fname_thumb = InspiralUtils.savefig_pylal( filename=fname )
      fnameList.append(fname)
      tagList.append(text)

  if opts.ifar_dist:
    figure(figure_number)
    figure_number += 1
    xmin = numpy.inf
    xmax = -numpy.inf
    ymin = 0.8
    ymax = 0
    for thisfile,lnsymbol in zip(corsefiles,symbols):
      if coincT[thisfile].sngl_table: # if have foreground trigs
        IFAR = []
        for coinc in coincT[thisfile]:
          if coinc.stat == 0.: # set IFAR to maximum IFAR, which is the num. of slides * time(y)
            IFAR.append( float(opts.num_slides)*2 * AnTime[thisfile] )
          else:
            IFAR.append( (1./coinc.stat) * AnTime[thisfile] )
        IFAR = array(IFAR) # turn into a matplotlib array
        # generate cumnum array (the y-axis in the plot)
        cumnum = []
        for ii in range(len(IFAR)):
          cumnum.append( len( (IFAR>=IFAR[ii]).nonzero()[0] ))
        # set colors and symbos and plot IFAR for this category;
        # note that assuming the ifos are all the same in that file
        # !!! FOLLOWING COLOR CODES FOR IFO COINC AND MASS BIN IS A TEMP
        # HACK; NEEDS TO BE AUTOMATED
        coinc_ifos = coincT[thisfile][0].get_ifos()[0]
        if coinc_ifos == 'H1L1':
          color = 'g'
        elif coinc_ifos == 'H2L1':
          color = 'r'
        elif coinc_ifos == 'H1H2L1':
          color = 'c'
        # set mass bin symbols
        mass = thisfile.split("/")[len(thisfile.split("/"))-2]
        if mass == 'mchirp_2_8':
          symbol = '^'
          lbl = coinc_ifos + " low-mass"
        elif mass == 'mchirp_8_17':
          symbol = 'o'
          lbl = coinc_ifos + " medium-mass"
        elif mass == 'mchirp_17_35':
          symbol = 'D'
          lbl = coinc_ifos + " high-mass"
        loglog( IFAR, cumnum, color+symbol, markerfacecolor=color,
                  markeredgecolor=color, alpha=0.65, 
                  label=lbl)
        hold(True)
        if xmin > IFAR[0]: # reset xmin
          xmin = IFAR[0]
        if xmax < IFAR[len(IFAR)-1]: # reset xmax
          xmax = IFAR[len(IFAR)-1]
        if ymax < cumnum[0]: # reset max
          ymax = cumnum[0]
      else:
        warn_msg = "File %s has no foreground triggers" %(thisfile)
        print >> sys.stdout, warn_msg
        if opts.show_min_bkg_ifar or opts.show_max_bkg_ifar:
          color = 'm' # for background lines
          if ymax == 0: ymax = 100
      # plot min bkg lines
      if opts.show_min_bkg_ifar:
        xminbkg = (2*float(opts.num_slides)/NbkgCoinc[thisfile])*AnTime[thisfile]
        loglog( [xminbkg,xminbkg], [ymin,ymax*1.2], color, linestyle=lnsymbol,
                linewidth=2 )
        xmin = xminbkg
      # end if have foreground eval.
      # plot background; note that this is occuring in the corsefiles loop,
      # whereas in IFAN plots it happens outside. This is because if a
      # category has a different amount of analysis time, the background will
      # be different (i.e., we have to normalize the background according to
      # whatever the analysis time was) 
      xbkg = numpy.logspace( -6, 2, num=100, endpoint=True, base=10.0 )
      ybkg = (1./xbkg) * AnTime[thisfile] # normalize
      loglog( xbkg, ybkg, 'k--', linewidth=2 )
      # plot error
      bkgplus = ybkg + sqrt(ybkg)
      bkgminus = ybkg - sqrt(ybkg)
      bkgminus = where( bkgminus<=0, 1e-5, bkgminus ) # prevent (-) values
      xs, ys = poly_between( xbkg, bkgminus, bkgplus )
      fill( xs, ys, facecolor='y', alpha=0.2 )
      # plot max bkg line (note that this is only approx.
      if opts.show_max_bkg_ifar:
        xmaxbkg = 2*float(opts.num_slides)*AnTime[thisfile]
        loglog( [xmaxbkg,xmaxbkg], [ymin,ymax*1.2], color, linestyle='-',
                linewidth=2, alpha=0.6)
      # end loop over coinc tables
    # set xmin, xmax, ymax to be slightly smaller/larger
    xmin = xmin * 0.8
    xmax = xmax * 1.2
    ymax = ymax * 1.2
    xlim(xmin,xmax)
    ylim(ymin,ymax)
    xlabel( r"Inverse False Alarm Rate (years)", size='x-large' )
    ylabel( r"Cumulative \#", size='x-large' )
    legend()
    if opts.enable_output is True:
      name = "cumhist_ifar"
      text = "Cumulative Histogram of IFAR distribution"
      fname = InspiralUtils.set_figure_name(opts, name)
      fname_thumb = InspiralUtils.savefig_pylal( filename=fname )
      fnameList.append(fname)
      tagList.append(text)

if opts.combine_ifan:
  figure(figure_number)
  figure_number += 1
  xmin = numpy.inf
  xmax = float(opts.num_slides)*2.2
  ymin = 0.8
  ymax = 0
  # plotting method is similar as uncombined plots, but since all FANs are
  # already in the list FANc, can just use this to make the IFANc array
  IFANc = []
  for fan in FANc:
    if fan == 0: 
      IFANc.append( float(opts.num_slides)*2 )
    else:
      IFANc.append( 1./fan )
  IFANc = array(IFANc)
  cumnum = []
  for ii in range( len(IFANc)):
    cumnum.append( len( (IFANc>=IFANc[ii]).nonzero()[0] ))
  loglog( IFANc, cumnum, 'b'+'^', markerfacecolor='b',
        markeredgecolor='b', alpha=0.65, label='Combined Triggers' )
  hold(True)
  # set xmin and ymax to be slightly smaller/larger then minIFANc/maxnum
  xmin = IFANc[0] * 0.8
  ymax = cumnum[0] * 1.2
  # plot background
  xbkg = numpy.logspace( -4, 2, num=100, endpoint=True, base=10.0 )
  ybkg = 1./xbkg
  loglog( xbkg, ybkg, 'k--', linewidth=2, label='Background' )
  # plot error
  bkgplus = ybkg + sqrt(ybkg)
  bkgminus = ybkg - sqrt(ybkg)
  bkgminus = where( bkgminus<=0, 1e-5, bkgminus ) # prevent (-) values
  xs, ys = poly_between( xbkg, bkgminus, bkgplus )
  fill( xs, ys, facecolor='y', alpha=0.2, label='$N^{1/2}$ errors' )
  xlim(xmin,xmax)
  ylim(ymin,ymax)
  xlabel( r"Inverse False Alarm Number", size='x-large' )
  ylabel( r"Cumulative \#", size='x-large' )
  legend()
  if opts.enable_output is True:
    name = "cumhist_ifan_combined"
    text = "Combined Cumulative Histogram of IFAN distribution"
    fname = InspiralUtils.set_figure_name(opts, name)
    fname_thumb = InspiralUtils.savefig_pylal( filename=fname )
    fnameList.append(fname)
    tagList.append(text)

# ============================================================================
# final step: html, cache file generation
if opts.enable_output is True:
  html_filename = InspiralUtils.write_html_output(opts, args, fnameList, tagList)
  InspiralUtils.write_cache_output(opts, html_filename, fnameList)
# ============================================================================

if opts.show_plot:
  show()





