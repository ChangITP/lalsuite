#!/usr/bin/python
#
# Copyright (C) 2012 Matthew West
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                 Preamble
#
# =============================================================================
#

from optparse import OptionParser
import sqlite3
import sys
import os

import numpy
import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot
from matplotlib import rcParms

from glue.lal import CacheEntry
from glue.ligolw import dbtables
from pylal import efficiency

__author__ = "Matthew West <matthew.west@ligo.org>"
__version__ = "git id %s" % git_version.id
__date__ = git_version.date

description = """
    %prog calculates the detection efficiency as a function of distance. 
    The produces plots for efficiency and cumulative VxT vs distance, as
    well as total VxT vs FAR threshold.
    """


#
# =============================================================================
#
#                                Command Line
#
# =============================================================================
#


def parse_command_line():
    """
    Parse the command line.
    """
    parser = OptionParser(
        version = "Name: %%prog\n%s" % git_version.verbose_msg,
        usage = "%prog [options]",
        description = description
        )
    parser.add_option("-c", "--database-cache", type="string", default=None,
        metavar = "name",
        help = "Get database files from the LAL cache named filename. [Required]"
        )
    parser.add_option( "-t", "--tmp-space", action="store", type="string", default=None,
        metavar = "PATH",
        help =
            "Location of local disk on which to do work. This is optional; " +
            "it is only used to enhance performance in a networked " +
            "environment. "
        )
    parser.add_option( "-P", "--output-path", action = "store", type = "string",
        default = os.getcwd(), metavar = "PATH",
        help =
            "Path where the figures should be stored. Default is current directory."
        )
    parser.add_option("--num-dist-bins", type="int", default=10,
        metavar = "INT",
        help = "The number of distance bins for the efficiency histogram"
        )
    parser.add_option("--distance-scale", type="string", default="linear",
        metavar = "string",
        help = 
            "How the distance bins are broken up. The default option is 'linear'." +
            "The alternative is 'log'."
        )
    parser.add_option("--distance-type", type="string", default="distance",
        metavar = "string",
        help =
            "The desired distance parameter the efficiency histogram will be " +
            "broken up in. The default option is physical distance. The only " +
            "alternative right now is physical distance weighted by the chirp " +
            "mass: 'chirp_dist'."
        )
    parser.add_option("--veto-category", type="int",
        metavar = "INT",
        help = "The highest DQ veto category the triggers survive. [Required]"
        )
    parser.add_option("--on-instruments", type="string",
        metavar = "IFOS"
        help = 
            "A comma separated string of the instruments one wishes to " +
            "calculate the efficiency for. Example: 'H1,L1,V1' [Required]"
        )
    parser.add_option("--database-tags", type="string",
        metavar = "'tag-1,tag-2,...'",
        help =
            "The usertag for the injection run(s) used to compute an efficiency. " +
            "The default is 'ALL_INJ'."
        )
    parser.add_option("--inj-usertag", type="string", default="ALL_INJ",
        metavar = "usertag"
        help =
            "The usertag for the injection run(s) used to compute an efficiency. " +
            "The default is 'ALL_INJ'."
        )
    parser.add_option("-v", "--verbose", action = "store_true", default = False,
        help = "Be verbose."
        )

    options, arguments =  parser.parse_args()

    required_options = ["database_cache","database_tags","veto_category","on_instruments"]
    missing_options = [option for option in required_options if not getattr(options, option)]

    if missing_options:
        missing_options = ', '.join([
            "--%s" % option.replace("_", "-")
            for option in missing_options
        ])
        raise ValueError, "missing required option(s) %s" % missing_options

#
# =============================================================================
#
#                                    Main
#
# =============================================================================
#


#
# Command line
#

opts = parse_command_line()

# get database url paths from cache
database_list = [CacheEntry(line).path() for line in file(opts.database_cache)]
# make list of database tags
db_tags = opts.database_tags.split(',')

on_ifos = ','.join(sorted(opts.on_instruments.split(','))).upper()
veto_cat = 'VETO_CAT%i_CUMULATIVE' % opts.veto_category

VT_dict = {}
eff_dict = {}

for db_idx, db_path in enumerate(database_list):

    # Setup working databases and connections
    db_tag = db_tags[db_idx]
    working_filename = dbtables.get_connection_filename(
        db_path,
        tmp_path=opts.tmp_space,
        verbose=opts.verbose)
    connection = sqlite3.connect( working_filename )
    if opts.tmp_space:
        dbtables.set_temp_store_directory(
            connection,
            opts.tmp_space,
            verbose=opts.verbose)
    dbtables.DBTable_set_connection( connection )
    
    # create indices to aid database queries
    sqlscript = """
    CREATE INDEX ci_idx ON coinc_inspiral (coinc_event_id);
    CREATE INDEX cem_idx ON coinc_event_map (coinc_event_id, event_id);
    CREATE INDEX si_idx ON sngl_inspiral (event_id, snr, chisq, chisq_dof, mchirp, eta);
    CREATE INDEX em_idx ON experiment_map (coinc_event_id, experiment_summ_id);
    CREATE INDEX es_idx ON experiment_summary (experiment_summ_id, datatype);
    """
    connection.executescript( sqlscript )

    # get lists of the found injections and their associated FAR values
    found_inj, found_fars = efficiency.found_injections(
        connection,
        opts.inj_usertag,
        on_ifos,
        veto_cat,
        verbose = opts.verbose)

    # get list of tuples containing all injections that went in during desired coinc time
    all_inj = efficiency.successful_injections(
        connection,
        opts.inj_usertag,
        on_ifos,
        veto_cat,
        distance_type = opts.distance_type,
        source_ref = opts.source_ref,
        verbose = opts.verbose)

    secINyear = 60.*60.*24.*365.25
    # Determine the minimum false_alarm_rate one can estimate from slides
    minFAR = secINyr / efficiency.get_livetime(connection, veto_cat, on_ifos, 'slide')
    far_list = minFAR * numpy.logspace(start=3.5, stop=1, num=1e4)
    far_list = numpy.append(far_list, 0.0)
    # Calculate the foreground search time in years
    zerolag_time = efficiency.get_livetime(connection, veto_cat, on_ifos, 'all_data')

    # make the distance bins for the efficiency histogram
    dist = inj_dist_range(
        connection,
        opts.inj_usertag,
        dist_type = opts.distance_type,
        dist_scale = opts.distance_scale,
        source_ref = opts.source_ref,
        num_bins = opts.num_dist_bins)

    # close connection
    connection.close()
    dbtables.discard_connection_filename(
        opts.database,
        working_filename,
        verbose=opts.verbose)
    # ------------------------- For Each FAR Threshold ------------------------- #

    # compute eff vs distance array
    eff_dict[db_tag] = efficiency.detection_efficiency(
        all_inj,
        found_inj, found_fars,
        far_list)
    # compute Volume*Time vs distance array
    VT_dict[db_tag] = efficiency.get_four_volume(eff_dict, dist, zerolag_time)
    # create a dictionary for the total VT as a function of FAR
    sumVT_dict[dbtag] = dict([(FAR,numpy.sum(VT)) for FAR, VT VT ])

# -------------------------------- Making Plots ------------------------------- #
if opts.verbose:
    print >> sys.stdout, "Making Efficient and 4-Volume Plots"

# shared plotting parameters
plotting_params = {
    'font.size': 16,
    'text.usetex': True,
    'xtick.labelsize': 'medium',
    'ytick.labelsize': 'medium',
    'axes.grid': False,
    'axes.titlesize': 'medium',
    'axes.labelsize': 'medium',
    'grid.color': 'k',
    'grid.linestyle': '-',
    'legend.fontsize': 'medium',
    'legend.loc': 'lower right',
    'legend.numpoints': 1
}
rcParams.update(plotting_params)

start_time, end_time = connection.execute(
    'SELECT DISTINCT gps_start_time, gps_end_time FROM experiment'
    ).fetchone()

# plot basename
plot_basename = '-'.join([
    on_ifos,
    '%s',
    opts.inj_usertag,
    'CAT_%i_VETO', 
    str(start_time), str(end_time - start_time) ])

# making total VT vs FAR plot
if opts.verbose:
    print >> sys.stdout, "\tTotal 4-Volume (VxT) vs FAR threshold"

VT_FAR = pyplot.figure().add_subplot(111)

for idx, db_tag in enumerate(db_tags):
    VT_FAR.semilogx(sumVT_dict[db_tag].keys(), sumVT_dict[db_tag].values(),
        label=db_tag, linestyle='None',
        marker='.', markersize=10)

VT_FAR.grid(which='major', linewidth=0.75)
VT_FAR.grid(which='minor', linewidth=0.25)

VT_FAR.set_xlabel( r'False Alarm Rate Threshold $(yr^{-1})$' )
VT_FAR.set_ylabel( r'Total Effective 4-Volume $(Mpc^{3}yr)$' )
VT_FAR.set_title( r'Pipeline Efficiency Comparison - VT vs FAR' )
VT_FAR.legend()

plot_name = plot_basename % ('VT_vs_FAR', opts.veto_category)
pyplot.savefig(plot_name + '.png', dpi=100, format='png')
pyplot.close(VT_FAR)

# Making cumulative VT vs distance plot for FAR=0 threshold
if opts.verbose:
    print >> sys.stdout, "\tCumulative 4-Volume (VxT) vs %s" % opts.distance_type

VT_Dist = pyplot.figure().add_subplot(111)

for idx, db_tag in enumerate(db_tags):
    VT_Dist.semilogx(dist[1:], numpy.cumsum(VT_dict[db_tag][0.0]),
        label=db_tag, linestyle='None',
        marker='.', markersize=10)

VT_Dist.grid(which='major', linewidth=0.75)
VT_Dist.grid(which='minor', linewidth=0.25)

VT_Dist.set_xlabel( r'Distance to Outer Edge of 3-Volume $(Mpc)$' )
VT_Dist.set_ylabel( r'Total Effective 4-Volume $(Mpc^{3}yr)$' )
VT_Dist.set_title( r'Pipeline Efficiency Comparison - VT vs Distance' )
VT_Dist.legend()

plot_name = plot_basename % ('VT_vs_Dist', opts.veto_category)
pyplot.savefig(plot_name + '.png', dpi=100, format='png')
pyplot.close(VT_Dist)

# Making efficiency vs distance plot for FAR=0 threshold
if opts.verbose:
    print >> sys.stdout, "\tDetection Efficiency vs %s" % opts.distance_type

Eff_Dist = pyplot.figure().add_subplot(111)

for idx, db_tag in enumerate(db_tags):
    Eff_Dist.semilogx(dist[1:], eff_dict[db_tag][0.0]),
        label=db_tag, linestyle='None',
        marker='.', markersize=10)

Eff_Dist.grid(which='major', linewidth=0.75)
Eff_Dist.grid(which='minor', linewidth=0.25)

Eff_Dist.set_xlabel( r'Distance to Outer Edge of 3-Volume $(Mpc)$' )
Eff_Dist.set_ylabel( r'Fraction of Recovered Injections in Bin' )
Eff_Dist.set_title( r'Pipeline Efficiency Comparison - Efficiency vs Distance' )
Eff_Dist.legend()

plot_name = plot_basename % ('Eff_vs_Dist', opts.veto_category)
pyplot.savefig(plot_name + '.png', dpi=100, format='png')
pyplot.close(Eff_Dist)

# When all plots are made, exit
if opts.verbose:
    print >> sys.stdout, "Finished!"
sys.exit(0)

