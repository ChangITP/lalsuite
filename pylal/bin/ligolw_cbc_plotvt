#!/usr/bin/python
#
# Copyright (C) 2012 Matthew West
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                 Preamble
#
# =============================================================================
#

from optparse import OptionParser
import sqlite3
import sys
import os

import numpy
import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot
from matplotlib import rcParams

from glue.lal import CacheEntry
from glue.ligolw import dbtables
from pylal import efficiency
from pylal import git_version

__author__ = "Matthew West <matthew.west@ligo.org>"
__version__ = "git id %s" % git_version.id
__date__ = git_version.date

description = """
    %prog calculates the detection efficiency as a function of distance. 
    The produces plots for efficiency and cumulative VxT vs distance, as
    well as total VxT vs FAR threshold.
    """


#
# =============================================================================
#
#                                Command Line
#
# =============================================================================
#


def parse_command_line():
    """
    Parse the command line.
    """
    parser = OptionParser(
        version = "Name: %%prog\n%s" % git_version.verbose_msg,
        usage = "%prog [options]",
        description = description
        )
    parser.add_option("-c", "--database-cache", type="string",
        metavar = "name",
        help = "Get database files from the LAL cache named filename. [Required]"
        )
    parser.add_option( "-t", "--tmp-space", action="store", type="string", default=None,
        metavar = "PATH",
        help =
            "Location of local disk on which to do work. This is optional; " +
            "it is only used to enhance performance in a networked " +
            "environment. "
        )
    parser.add_option( "-P", "--output-path", action = "store", type = "string",
        default = os.getcwd(), metavar = "PATH",
        help =
            "Path where the figures should be stored. Default is current directory."
        )
    parser.add_option("--distance-scale", type="string", default="linear",
        metavar = "string",
        help = 
            "How the distance bins are broken up. The default option is 'linear'." +
            "The alternative is 'log'."
        )
    parser.add_option("--distance-step", type="float", default=4.0,
        metavar = "float",
        help =
            "The step size for distance bins used in the efficiency calculation." +
            "If the distance scale is 'linear', then step=d[j+1]-d[j]. If the " +
            "scale is 'log', then step=d[j+1]/d[j]. The default value is 4.0"
        )
    parser.add_option("--distance-type", type="string", default="distance",
        metavar = "string",
        help =
            "The desired distance parameter the efficiency histogram will be " +
            "broken up in. The default option is 'distance'. The " +
            "alternative is 'decisive_distance' ala the second largest effective " +
            "distance from a found signal."
        )
    parser.add_option("--source-ref", type="string", default=None,
        metavar = "{NSNS,NSBH,BHBH}",
        help =
            "The source type used to weight the distance values.  The default " +
            "is None."
        )
    parser.add_option("--veto-category", type="int",
        metavar = "INT",
        help = "The highest DQ veto category the triggers survive. [Required]"
        )
    parser.add_option("--on-instruments", type="string",
        metavar = "IFOS",
        help = 
            "A comma separated string of the instruments one wishes to " +
            "calculate the efficiency for. Example: 'H1,L1,V1' [Required]"
        )
    parser.add_option("--database-tags", type="string",
        metavar = "'tag-1,tag-2,...'",
        help =
            "The usertag for the injection run(s) used to compute an efficiency. " +
            "The default is 'ALL_INJ'."
        )
    parser.add_option("--inj-usertag", type="string", default="ALL_INJ",
        metavar = "usertag",
        help =
            "The usertag for the injection run(s) used to compute an efficiency. " +
            "The default is 'ALL_INJ'."
        )
    parser.add_option("-v", "--verbose", action = "store_true", default = False,
        help = "Be verbose."
        )

    options, arguments =  parser.parse_args()

    required_options = ["database_cache","database_tags","veto_category","on_instruments"]
    missing_options = [option for option in required_options if not getattr(options, option)]

    if missing_options:
        missing_options = ', '.join([
            "--%s" % option.replace("_", "-")
            for option in missing_options
        ])
        raise ValueError, "missing required option(s) %s" % missing_options

    return options

#
# =============================================================================
#
#                                    Main
#
# =============================================================================
#


#
# Command line
#

opts = parse_command_line()

# get database url paths from cache
database_list = [CacheEntry(line).path for line in file(opts.database_cache)]
# make list of database tags
db_tags = opts.database_tags.split(',')

on_ifos = ','.join(sorted(opts.on_instruments.split(','))).upper()
veto_cat = 'VETO_CAT%i_CUMULATIVE' % opts.veto_category

eff_dict = {}; deff_dict = {}
VT_dict = {}; dVT2_dict = {}
dist = {}

for db_idx, db_path in enumerate(database_list):

    # Setup working databases and connections
    db_tag = db_tags[db_idx]
    if opts.verbose:
        print >> sys.stdout, "Set up connection for %s database" % db_tag

    working_filename = dbtables.get_connection_filename(
        db_path,
        tmp_path=opts.tmp_space,
        verbose=opts.verbose)
    connection = sqlite3.connect( working_filename )
    if opts.tmp_space:
        dbtables.set_temp_store_directory(
            connection,
            opts.tmp_space,
            verbose=opts.verbose)
    dbtables.DBTable_set_connection( connection )
    
    # create indices to aid database queries
    sqlscript = """
    CREATE INDEX ci_idx ON coinc_inspiral (coinc_event_id);
    CREATE INDEX cem_idx ON coinc_event_map (coinc_event_id, event_id);
    CREATE INDEX si_idx ON sngl_inspiral (event_id, snr, chisq, chisq_dof, mchirp, eta);
    CREATE INDEX em_idx ON experiment_map (coinc_event_id, experiment_summ_id);
    CREATE INDEX es_idx ON experiment_summary (experiment_summ_id, datatype);
    """
    connection.executescript( sqlscript )

    #
    # get lists of the found injections and their associated FAR values
    # each entry in found_inj is the tuple (simulation_id, gps_end_time, distance)
    #
    if opts.verbose:
        print >> sys.stdout, "\tGet list of found injections"

    found_inj, found_fars = efficiency.found_injections(
        connection,
        opts.inj_usertag,
        on_ifos,
        dist_type = opts.distance_type,
        source_ref = opts.source_ref,
        verbose = opts.verbose)

    # get list of tuples containing all injections that went in during desired coinc time
    all_inj = efficiency.successful_injections(
        connection,
        opts.inj_usertag,
        on_ifos,
        veto_cat,
        dist_type = opts.distance_type,
        source_ref = opts.source_ref,
        verbose = opts.verbose)

    secINyear = 60.*60.*24.*365.25
    # Determine the minimum false_alarm_rate one can estimate from slides
    minFAR = secINyear / efficiency.get_livetime(connection, veto_cat, on_ifos, 'slide')
    far_list = minFAR * numpy.logspace(start=3.5, stop=1, num=1e4)
    far_list = numpy.append(far_list, 0.0)
    # Calculate the foreground search time in years
    T_fgd = efficiency.get_livetime(connection, veto_cat, on_ifos, 'all_data') / secINyear

    # make the distance bins for the efficiency histogram
    dist[db_tag] = efficiency.inj_dist_range(
        numpy.array([inj[2] for inj in all_inj]),
        dist_scale = opts.distance_scale,
        step = opts.distance_step)

    # ------------------------- For Each FAR Threshold ------------------------- #

    # compute eff vs distance array
    if opts.verbose:
        print >> sys.stdout, "\tCompute the efficiency vs distance and associate errors"
    eff_dict[db_tag], deff_dict[db_tag] = efficiency.detection_efficiency(
        all_inj,
        found_inj, found_fars,
        far_list,
        dist[db_tag])

    # compute Volume*Time vs distance array
    if opts.verbose:
        print >> sys.stdout, "\tCompute the VxT vs distance and associated variance"
    VT_dict[db_tag], dVT2_dict[db_tag] = efficiency.get_four_volume(
        eff_dict[db_tag], deff_dict[db_tag],
        dist[db_tag], T_fgd)

    start_time, end_time = connection.execute(
        'SELECT DISTINCT gps_start_time, gps_end_time FROM experiment'
        ).fetchone()

    # close connection
    connection.close()
    dbtables.discard_connection_filename(
        db_path,
        working_filename,
        verbose=opts.verbose)

#										#
# -------------------------------- Making Plots ------------------------------- #
#										#
if opts.verbose:
    print >> sys.stdout, "Making Efficient and 4-Volume Plots"

# shared plotting parameters
plotting_params = {
    'font.size': 16,
    'text.usetex': True,
    'xtick.labelsize': 'medium',
    'ytick.labelsize': 'medium',
    'axes.grid': False,
    'axes.titlesize': 'medium',
    'axes.labelsize': 'medium',
    'grid.color': 'k',
    'grid.linestyle': ':',
    'legend.fontsize': 'smaller',
    'legend.numpoints': 1
}
rcParams.update(plotting_params)

# plot basename
plot_basename = '-'.join([
    on_ifos,
    '%s',
    opts.inj_usertag,
    'CAT_%i_VETO', 
    str(start_time), str(end_time - start_time) ])

# set xlim for X_vs_Distance plots
max_dist = 0.0
for tag, eff in eff_dict.items():
    try:
        max_dist = max(max_dist, dist[tag][list(eff[0.0]).index(0.0)+1])
    except ValueError:
        max_dist = max(max_dist, numpy.max(dist[tag]))
min_dist = numpy.min(dist.values())

# determine xlim_max for FAR_vs_VT plot
maxFAR = max([numpy.max(eff.keys()) for eff in eff_dict.values()])

# --------------------- Efficiency vs Distance for FAR=0 -------------------- #
if opts.verbose:
    print >> sys.stdout, "\tDetection Efficiency vs %s" % opts.distance_type

Eff_Dist_fig = pyplot.figure()
Eff_Dist_plot = Eff_Dist_fig.add_subplot(111)

for idx, db_tag in enumerate(db_tags):
    Eff_Dist_plot.errorbar(
        dist[db_tag][1:], eff_dict[db_tag][0.0],
        deff_dict[db_tag][0.0],
        label=db_tag, linestyle='None',
        marker='.', markersize=10)

Eff_Dist_plot.grid(which='major', linewidth=0.75)
Eff_Dist_plot.grid(which='minor', linewidth=0.25)
Eff_Dist_plot.set_xscale(opts.distance_scale)
Eff_Dist_plot.set_xlim(min_dist, max_dist)

Eff_Dist_plot.set_xlabel( r'Distance to Outer Edge of 3-Volume $(Mpc)$' )
Eff_Dist_plot.set_ylabel( r'Fraction of Recovered Injections in Bin' )
Eff_Dist_plot.set_title(
    r'Detection Efficiency vs %s' % opts.distance_type.replace('_',' ').title()
    )
Eff_Dist_plot.legend(loc='lower left')

plot_name = plot_basename % ('Eff_vs_Dist', opts.veto_category)
pyplot.savefig(plot_name + '.png', dpi=100, format='png')
pyplot.close(Eff_Dist_fig)

# ------------------------- VxT vs Distance for FAR=0 ------------------------ #
if opts.verbose:
    print >> sys.stdout, "\tCumulative 4-Volume (VxT) vs %s" % opts.distance_type

VT_Dist_fig = pyplot.figure()
VT_Dist_plot = VT_Dist_fig.add_subplot(111)

for idx, db_tag in enumerate(db_tags):
    VT_Dist_plot.errorbar(
        dist[db_tag][1:], VT_dict[db_tag][0.0],
        numpy.sqrt(dVT2_dict[db_tag][0.0]),
        label=db_tag, linestyle='None',
        marker='.', markersize=10)

VT_Dist_plot.grid(which='major', linewidth=0.75)
VT_Dist_plot.grid(which='minor', linewidth=0.25)
VT_Dist_plot.set_xscale(opts.distance_scale)
VT_Dist_plot.set_yscale(opts.distance_scale)
VT_Dist_plot.set_xlim(min_dist, max_dist)

VT_Dist_plot.set_xlabel( r'Distance to Outer Edge of 3-Volume $(Mpc)$' )
VT_Dist_plot.set_ylabel( r'Total Effective 4-Volume $(Mpc^{3}yr)$' )
VT_Dist_plot.set_title( r'VxT vs %s' % opts.distance_type.replace('_',' ').title() )
VT_Dist_plot.legend(loc='lower right')

plot_name = plot_basename % ('VT_vs_Dist', opts.veto_category)
pyplot.savefig(plot_name + '.png', dpi=100, format='png')
pyplot.close(VT_Dist_fig)

# -------------------------------- VxT vs FAR ------------------------------- #
if opts.verbose:
    print >> sys.stdout, "\tTotal 4-Volume (VxT) vs FAR threshold"

VT_FAR_fig = pyplot.figure()
VT_FAR_plot = VT_FAR_fig.add_subplot(111)

for idx, db_tag in enumerate(db_tags):
    # the way to plot FAR=0 point on a log plot
    zeroFAR_VT = VT_dict[db_tag].pop(0.0)
    new_minFAR = 10**numpy.floor(numpy.log10(numpy.min(VT_dict[db_tag].keys())))
    VT_dict[db_tag][new_minFAR] = zeroFAR_VT
    dVT2_dict[db_tag][new_minFAR] = dVT2_dict[db_tag].pop(0.0)

    VT_FAR_plot.errorbar(
        VT_dict[db_tag].keys(), numpy.max(VT_dict[db_tag].values(), axis=1),
        numpy.sqrt(numpy.max(dVT2_dict[db_tag].values(), axis=1)),
        label=db_tag, linestyle='None',
        marker='.', markersize=10)

VT_FAR_plot.grid(which='major', linewidth=0.75)
VT_FAR_plot.grid(which='minor', linewidth=0.25)
VT_FAR_plot.set_xscale('log')
VT_FAR_plot.set_yscale(opts.distance_scale)
VT_FAR_plot.set_xlim(new_minFAR, 2.0*maxFAR)

VT_FAR_plot.set_xlabel( r'False Alarm Rate Threshold $(yr^{-1})$' )
VT_FAR_plot.set_ylabel( r'Total Effective 4-Volume $(Mpc^{3}yr)$' )
VT_FAR_plot.set_title( r'Pipeline Efficiency Comparison - VT vs FAR' )
VT_FAR_plot.legend(loc='lower right')

plot_name = plot_basename % ('VT_vs_FAR', opts.veto_category)
pyplot.savefig(plot_name + '.png', dpi=100, format='png')
pyplot.close(VT_FAR_fig)



# When all plots are made, exit
if opts.verbose:
    print >> sys.stdout, "Finished!"
sys.exit(0)

