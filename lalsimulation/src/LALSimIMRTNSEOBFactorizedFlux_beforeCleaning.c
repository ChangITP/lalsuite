/*
*  Copyright (C) 2010 Craig Robinson 
*
*  This program is free software; you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation; either version 2 of the License, or
*  (at your option) any later version.
*
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with with program; see the file COPYING. If not, write to the
*  Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
*  MA  02111-1307  USA
*/


/**
 * \author Craig Robinson
 *
 * \brief Function to compute the factorized flux as uses in the new EOBNR_PP
 * model. Flux function given by Phys.Rev.D79:064004,2009.
 */

#include <complex.h>

#ifndef _LALSIMIMRFACTORIZEDFLUX_C
#define _LALSIMIMRFACTORIZEDFLUX_C

/**
 * This function calculates the factorized flux in the EOB dynamics for
 * the EOBNR (and potentially subsequent) models. The flux function
 * is found in Phys.Rev.D79:064004,2009.
 *
 */

static REAL8 XLALSimIMRTNSEOBFactorizedFlux(
                      REAL8Vector  *values, /**<< Dynamics r, phi, pr, pphi */
                      const REAL8  omega,   /**<< Angular frequency omega */
                      TNSEOBParams    *ak,     /**<< Structure containing pre-computed parameters */
                      const INT4   lMax,     /**<< Maximum l to include when calculating flux (between 2 and 8) */
                      REAL8 eta,
					  REAL8 mass1,
					  REAL8 mass2,
					  REAL8 lambda1,
					  REAL8 lambda2
					 )

{ // Note :  XLALSimIMRTNSEOBFactorizedFlux give you F_phi. Does not include the radial flux. 

  REAL8 flux = 0.0;
  REAL8 r, vPhi;
  REAL8 omegaSq;
  COMPLEX16 hLM;
  INT4 l, m;
  EOBNonQCCoeffs *nqcCoeffs;

#ifndef LAL_NDEBUG
  if ( !values || !ak )
  {
    XLAL_ERROR_REAL8( XLAL_EFAULT );
  }
#endif

  if ( lMax < 2 )
  {
    XLAL_ERROR_REAL8( XLAL_EINVAL );
  }

  nqcCoeffs = ak->nqcCoeffs;

//===============================TNSEOB uses non keplerian velocity corrections ======
  /* Omega is the derivative of phi */
//  omegaSq = omega*omega;
//v = cbrt( omega );
//
//======================================================================================

//nonKeplerianCoefficient gives psi.
r  = values->data[0];
vPhi = nonKeplerianCoefficient( values, eta,mass1,mass2,lambda1,lambda2 );
vPhi  = r * cbrt(vPhi);
vPhi *= omega;

omegaSq = omega*omega;

  /* In TNSEOB unlike in SEOBNRv2 all  modes get generated by */
  for ( l = 2; l <= lMax; l++ )
  {
    for ( m = 1; m <= l; m++ )
    {

      if ( XLALSimIMRTNSEOBGetFactorizedWaveform( &hLM, values, vPhi, l, m, ak )
             == XLAL_FAILURE )
      {
        XLAL_ERROR_REAL8( XLAL_EFUNC );
      }

      flux += (REAL8)(m * m) * omegaSq * (creal(hLM)*creal(hLM) + cimag(hLM)*cimag(hLM));
    }
  }


flux=flux * LAL_1_PI / 8.0;

// At this point we have Equation (39) in Damour et al (2013). So, what we have called as flux is actually F_lmax^scrii


  return flux;
}


//Coding newtonian flux like Sebastiano's code : 

static REAL8 XLALSimIMRTNSEOBNewtonianFlux(
                      REAL8 x,
                      REAL8 eta,
                      INT4 l,
                      INT4 m)

{ REAL8 fluxNewtonian = 0.0;

  

REAL8 eta2 = eta*eta;
REAL8 eta3 = eta*eta*eta;

REAL8 x2=x*x;
REAL8 x5  = x2*x2*x;
REAL8 x6  = x5*x;
REAL8 x7  = x6*x;
REAL8 x8  = x7*x;
REAL8 x9  = x8*x;
REAL8 x10 = x9*x;
REAL8 x11 = x10*x;
REAL8 x12 = x11*x;

REAL8 sp2 = 1.-4.*eta;
REAL8 sp3 = (1.-3.*eta)*(1.-3.*eta);
REAL8 sp4 = (1.-4.*eta)*(1.-2.*eta)*(1.-2.*eta);
REAL8 sp5 = (1.-5.*eta+5.*eta2)*(1.-5.*eta+5.*eta2);
REAL8 sp6 = (1.-4.*eta)*(3.*eta2-4.*eta +1.)*(3.*eta2-4.*eta +1.);
REAL8 sp7 = (1. - 7.*eta + 14.*eta2 - 7.*eta3)*(1. - 7.*eta + 14.*eta2 - 7.*eta3);



// Note that in the tidal part this has to be done!    sp2 = 1.0;


    
    REAL8 N22 =   32./5.        *       x5;
    REAL8 N21 =   8./45.        * sp2 * x6;
 
    
    REAL8 N33 = 243./28.        * sp2 * x6;
    REAL8 N32 = 32./63.         * sp3 * x7;
    REAL8 N31 = 1./1260        * sp2 * x6;
   

    REAL8 N44 = 8192./567.      * sp3 * x7;
    REAL8 N43 = 729./700.       * sp4 * x8;
    REAL8 N42 = 32./3969.       * sp3 * x7;
    REAL8 N41 = 1./44100.       * sp4 * x8;
 


    REAL8 N55 = 1953125./76032. * sp4 * x8;
    REAL8 N54 = 131072./66825.  * sp5 * x9;
    REAL8 N53 = 2187./70400.    * sp4 * x8;
    REAL8 N52 = 256./400950.    * sp5 * x9;
    REAL8 N51 = 1./19958400.    * sp4 * x8;
 
    
    REAL8 N66 = 839808./17875.             * sp5 * x9;
    REAL8 N65 = 48828125./13621608.        * sp6 * x10;
    REAL8 N64 = 4194304./47779875.         * sp5 * x9;
    REAL8 N63 = 59049./15415400.           * sp6 * x10;
    REAL8 N62 = 128./28667925.             * sp5 * x9;
    REAL8 N61 = 1./1123782660.             * sp6 * x10;
   

    REAL8 N77 = 96889010407./1111968000.   * sp6 * x10;
    REAL8 N76 = 5668704./875875.           * sp7 * x11;
    REAL8 N75 = 1220703125./5666588928. * sp6 * x10;
    REAL8 N74 = (4194304.*(1. - 7.*eta + 14.*eta2 - 7.*eta3)*(1. - 7.*eta + 14.*eta2 - 7.*eta3)*x11)/307432125.;
    REAL8 N73 = (1594323.*(1. - 4.*eta)*(1. - 4.*eta + 3.*eta2)*(1. - 4.*eta + 3.*eta2)*x10)/32064032000.;
    REAL8 N72 = (32.*(1. - 7.*eta + 14.*eta2 - 7.*eta3)*(1. - 7.*eta + 14.*eta2 - 7.*eta3)*x11)/135270135.;
    REAL8 N71 = ((1. - 4.*eta)*(1. - 4.*eta + 3.*eta2)*(1. - 4.*eta + 3.*eta2)*x10)/934987173120.;
   
    
    REAL8 N88 = (7.*eta3-14.*eta2+7.*eta-1.)*(7.*eta3-14.*eta2+7.*eta-1.)*274877906944./1688511825.*x11;
    REAL8 N87 = (4747561509943.*(1. - 4.*eta)*(1. - 6.*eta + 10.*eta2 - 4.*eta3)*(1. - 6.*eta + 10.*eta2 - 4.*eta3)*x12)/408314649600;
    REAL8 N86 = (51018336.*(1. - 7.*eta + 14.*eta2 - 7.*eta3)*(1. - 7.*eta + 14.*eta2 - 7.*eta3)*x11)/104229125;
    REAL8 N85 = (30517578125.*(1. - 4.*eta)*(1. - 6.*eta + 10.*eta2 - 4.*eta3)*(1. - 6.*eta + 10.*eta2 - 4.*eta3)*x12)/800296713216;
    REAL8 N84 = (4194304.*(1. - 7.*eta + 14.*eta2 - 7.*eta3)*(1. - 7.*eta + 14.*eta2 - 7.*eta3)*x11)/15679038375.;
    REAL8 N83 = (177147.*(1. - 4.*eta)*(1. - 6.*eta + 10.*eta2 - 4.*eta3)*(1. - 6.*eta + 10.*eta2 - 4.*eta3)*x12)/39642803200.;
    REAL8 N82 = (32.*(1. - 7.*eta + 14.*eta2 - 7.*eta3)*(1. - 7.*eta + 14.*eta2 - 7.*eta3)*x11)/34493884425.;
    REAL8 N81 = ((1. - 4.*eta)*(1. - 6.*eta + 10.*eta2 - 4.*eta3)*(1. - 6.*eta + 10.*eta2 - 4.*eta3)*x12)/81744592849920.;

printf("x in Newtonian %g\n", (double) x); 
if (eta==0)
   {
     fluxNewtonian=0.;
   }
  //This is the point test limit 
  //
  //

else
 {  //dealing with "non-test-particle"
  switch( l )
  {
    case 2:
      switch( abs(m) )
      {
        case 2:
        fluxNewtonian=N22;
        printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
     break;
        case 1:
        fluxNewtonian=N21;
        printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        default:
          XLAL_ERROR( XLAL_EINVAL );
          break;
      }
      break;
    case 3:
      switch (m)
      {
        case 3:
         fluxNewtonian=N33;
         printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 2:
        fluxNewtonian=N32;
        printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 1:
       fluxNewtonian=N31;
       printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        default:
          XLAL_ERROR( XLAL_EINVAL );
          break;
      }
      break;
    case 4:
      switch (m)
      {
        case 4:
         fluxNewtonian=N44;
         printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 3:
          fluxNewtonian=N43;
          printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 2:
          fluxNewtonian=N42;
          printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 1:
         fluxNewtonian=N41;
         printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        default:
          XLAL_ERROR( XLAL_EINVAL );
          break;
      }
      break;
    case 5:
      switch (m)
      {
        case 5:
         fluxNewtonian=N55;
         printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 4:
         fluxNewtonian=N54;
         printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 3:
         fluxNewtonian=N53;
         printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 2:
          fluxNewtonian=N52;
          printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 1:
         fluxNewtonian=N51;
         printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        default:
          XLAL_ERROR( XLAL_EINVAL );
          break;
      }
      break;
    case 6:
      switch (m)
      {
        case 6:
        fluxNewtonian=N66;
        printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 5:
         fluxNewtonian=N65;
         printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 4:
         fluxNewtonian=N64;
         printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 3:
         fluxNewtonian=N63;
         printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
        case 2:
         fluxNewtonian=N62;
         printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 1:
        fluxNewtonian=N61;
        printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        default:
          XLAL_ERROR( XLAL_EINVAL );
          break;
      }
      break;
    case 7:
      switch (m)
      {
        case 7:
         fluxNewtonian=N77;
         printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 6:
          fluxNewtonian=N76;
          printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 5:
         fluxNewtonian=N75;
         printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 4:
          fluxNewtonian=N74;
          printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 3:
          fluxNewtonian=N73;
          printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 2:
        fluxNewtonian=N72;
        printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 1:
         fluxNewtonian=N71;
         printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        default:
          XLAL_ERROR( XLAL_EINVAL );
          break;
      }
      break;
    case 8:
      switch (m)
      {
        case 8:
          fluxNewtonian=N88;
          printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 7:
          fluxNewtonian=N87;
          printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 6:
          fluxNewtonian=N86;
          printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 5:
          fluxNewtonian=N85;
          printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 4:
         fluxNewtonian=N84;
         printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 3:
          fluxNewtonian=N83;
          printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 2:
          fluxNewtonian=N82;
          printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        case 1:
          fluxNewtonian=N81;
          printf("fluxNewtonian %g\n", (double) fluxNewtonian); 
          break;
        default:
          XLAL_ERROR( XLAL_EINVAL );
          break;
      }
  
      break;
    default:
      XLAL_ERROR( XLAL_EINVAL );
      break;
}
}

  return fluxNewtonian;
}




//=====================================This section of the code is just for debugging. Delete/comment it out when your code starts working perfectly  ==================

UNUSED static REAL8 XLALSimIMRTNSEOBFactorizedFlux_Debugging(
                        REAL8Vector  *values, /**<< Dynamics r, phi, pr, pphi */
                      const REAL8  omega,   /**<< Angular frequency omega */
                      TNSEOBParams    *ak,     /**<< Structure containing pre-computed parameters */
                      const INT4   lMax,     /**<< Maximum l to include when calculating flux (between 2 and 8) */
                      REAL8 eta,
            REAL8 mass1,
            REAL8 mass2,
            REAL8 lambda1,
            REAL8 lambda2
           )

{ printf("Entering Debugging the Flux function"); 
     
  REAL8 flux = 0.0;
  REAL8 r, vPhi;
  REAL8 omegaSq;
  COMPLEX16 hLM;
  INT4 l, m;
  EOBNonQCCoeffs *nqcCoeffs;

#ifndef LAL_NDEBUG
  if ( !values || !ak )
  {
 XLAL_ERROR_REAL8( XLAL_EFAULT );
  }
#endif

  if ( lMax < 2 )
  {
    XLAL_ERROR_REAL8( XLAL_EINVAL );
  }

  nqcCoeffs = ak->nqcCoeffs;

//===============================TNSEOB uses non keplerian velocity corrections ======
  /* Omega is the derivative of phi */
//  omegaSq = omega*omega;
//v = cbrt( omega );
//
//======================================================================================

//nonKeplerianCoefficient gives psi.
r  = values->data[0];
REAL8 psi = nonKeplerianCoefficient( values, eta,mass1,mass2,lambda1,lambda2 );
REAL8 romega  = r * cbrt(psi);
//REAL8 romegaSq = romega*romega;
vPhi= romega*omega;
REAL8 x=vPhi*vPhi;
//REAL8 xKep=cbrt(omega*omega);
printf("xarg: %g\n", (double) vPhi*vPhi); 

REAL8 NewtonianFluxTemp;
printf("6.4 * x*x*x*x*x: %g\n", (double) 6.4 * x*x*x*x*x);
omegaSq = omega*omega;

//======changing it to redoing everything like sebastiano's code==========
  /* In TNSEOB unlike in SEOBNRv2 all  modes get generated by */
  //for ( l = 2; l <= lMax; l++ )
  //{
  //  for ( m = 1; m <= l; m++ )
  //  {

  //    if ( XLALSimIMRTNSEOBGetFactorizedWaveform_withoutNewtonianPart( &hLM, values, vPhi, l, m, ak )
  //           == XLAL_FAILURE )
  //   {
  //      XLAL_ERROR_REAL8( XLAL_EFUNC );
  //    }

  //    flux += (REAL8)(m * m) * omegaSq * (creal(hLM)*creal(hLM) + cimag(hLM)*cimag(hLM));
  //  }
  //}


for ( l = 2; l <= lMax; l++ )
  {
    for ( m = 1; m <= l; m++ )
    {

      if ( XLALSimIMRTNSEOBGetFactorizedWaveform_withoutNewtonianPart( &hLM, values, vPhi, l, m, ak )
             == XLAL_FAILURE )
     {
        XLAL_ERROR_REAL8( XLAL_EFUNC );
      }
       printf("l %g\n", (double) l);
        printf("m %g\n", (double) m);
    NewtonianFluxTemp = XLALSimIMRTNSEOBNewtonianFlux(x,eta, l, m);
   
    printf("modhatSqared %g\n", (double) (creal(hLM)*creal(hLM) + cimag(hLM)*cimag(hLM)));
    printf("modhatSqared *Fnewt %g\n", (double) ((creal(hLM)*creal(hLM) + cimag(hLM)*cimag(hLM))*NewtonianFluxTemp));

     // 
     // printf("%s\n",NewtonianFluxTemp );
      flux += (REAL8) ((creal(hLM)*creal(hLM) + cimag(hLM)*cimag(hLM))*NewtonianFluxTemp);

      NewtonianFluxTemp=0.;
      }
    }
//At this point we have what is named " Modhhatlm.^2" Fnewt in Sebastiano's code : 
       
      flux = flux/(6.4 * x*x*x*x*x);
      printf("fhat %g\n", (double) flux);
      flux = flux * 32.* (eta*omega*omega*omega*omega*omega*romega*romega*romega*romega)/5.;
//    }
  //}

//flux=flux * LAL_1_PI / 8.0;
//=============================================================================

//flux=flux+NewtonianFlux;


//From here on I am changing!
//Assume that the two waveforms produced are the same! Check the coeeficients ! 

//flux=flux/(LAL_1_PI*LAL_1_PI);
//flux=flux/(8.*LAL_1_PI);
//flux=flux/(6.4 * eta *eta*x*x*x*x*x);
//flux=-(32.*eta*romega*romega*romega*romega*omega*omega*omega*omega*omega*flux)/5.;
printf("flux that should match the ingoing flux: %g\n", (double) flux);





//This is me debugging.. IGONRE! ---------------------------------
//Is this correct or is what is coded correct? 
//flux=flux /(LAL_1_PI * 8.0);

// At this point we have Equation (39) in Damour et al (2013). So, what we have called as flux is actually F_lmax^scrii

//REAL8 vPhi5=vPhi*vPhi*vPhi*vPhi*vPhi;
//REAL8 vPhi10=vPhi5*vPhi5;

//flux=flux*romegaSq*romegaSq*omegaSq*omegaSq*omega/vPhi10;
//printf("correction factor: %g\n", (double) romegaSq*romegaSq*omegaSq*omegaSq*omega/vPhi10);
//---------------------------------------------
  return flux;
}


#endif /*_LALSIMIMRFACTORIZEDFLUX_C*/
