//
//  Copyright (C) 2011 Karl Wette
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with with program; see the file COPYING. If not, write to the
//  Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
//  MA  02111-1307  USA
//

// SWIG extensions to LAL date and time module
// Author: Karl Wette, 2011

// only if included as a SWIG interface file
#ifdef SWIG

///// Methods and operators for LAL GPS time class /////

// Make sure LIGOTimeGPS is defined.
%include <lal/LALDatatypes.h>

// Make sure LAL time functions are included.
%header %{#include <lal/Date.h>%}

%extend LIGOTimeGPS {

  // Construct a new LIGOTimeGPS. SWIG doesn't provide its usual
  // default constructor if custom constructors are supplied (as
  // they are below); a destructor is still generated, however,
  // as is a copy constructor if %copyctor is enabled globally.
  LIGOTimeGPS() {
    return new LIGOTimeGPS();
  }

  // Construct a LIGOTimeGPS from a real number.
  LIGOTimeGPS(REAL8 t) {
    return XLALGPSSetREAL8(new LIGOTimeGPS(), t);
  }

  // Construct a LIGOTimeGPS from integer seconds and nanoseconds.
  LIGOTimeGPS(INT4 gpssec, INT4 gpsnan) {
    return XLALGPSSet(new LIGOTimeGPS(), gpssec, gpsnan);
  }

  // We implement numeric operators by directly defining Python-style
  // __operator__ methods. While we could have also used C++ operators,
  // it seems that many SWIG language modules simply rename them to the
  // equivalent Python __operator__s, which are then called by the SWIG
  // run-time code for that language when a call to that operator is
  // generated. Using Pythons __operator__s directly also allows us to
  // use some nice __operator__s which do not exist in C++. For example,
  // a class X can provide __roperator__s for binary operations where X
  // appears on the right-hand side, e.g. '3.7 + X'; in this way all
  // binary operations on X can be implemented as methods of the class X.
  // Unfortunately, it seems that not all Python operators are currently
  // supported by other SWIG modules, e.g. Octave does not support the
  // __roperator__s as of SWIG 2.0.3.

  // Numeric unary operators
  LIGOTimeGPS* __pos__() {
    return XLALINT8NSToGPS($self, +XLALGPSToINT8NS($self));
  }
  LIGOTimeGPS* __neg__() {
    return XLALINT8NSToGPS($self, -XLALGPSToINT8NS($self));
  }

  // Additive binary operators are generated by the following SWIG macro.
  // NAME is the name of the Python operator and OP is the C operator.
  // If both operands are either LIGOTimeGPSs or integers, an integer OP
  // is performed on the GPS time converted to nanoseconds; otherwise, if
  // either operand is a real number, a floating-point OP is performed on
  // the GPS time converted to seconds.
  %define swiglal_LIGOTimeGPS_additive_operator(NAME, OP)

    // Normal (and reverse) __operator__s must be declared %newobject
    // since they will allocate and return new LIGOTimeGPS instances.
    %newobject __##NAME##__;
    %newobject __r##NAME##__;

    // Perform OP between two LIGOTimeGPSs, and
    // return the result as a new LIGOTimeGPS.
    LIGOTimeGPS* __##NAME##__(LIGOTimeGPS* tgps) {
      return XLALINT8NSToGPS(new LIGOTimeGPS(), XLALGPSToINT8NS($self) OP XLALGPSToINT8NS(tgps));
    }

    // Perform OP between a LIGOTimeGPS and an INT4, and
    // return the result as a new LIGOTimeGPS.
    LIGOTimeGPS* __##NAME##__(INT4 t) {
      return XLALINT8NSToGPS(new LIGOTimeGPS(), XLALGPSToINT8NS($self) OP (t * XLAL_BILLION_INT8));
    }

    // Perform OP between an INT4 and a LIGOTimeGPS, and
    // return the result as a new LIGOTimeGPS.
    LIGOTimeGPS* __r##NAME##__(INT4 t) {
      return XLALINT8NSToGPS(new LIGOTimeGPS(), (t * XLAL_BILLION_INT8) OP XLALGPSToINT8NS($self));
    }

    // Perform OP between a LIGOTimeGPS and a REAL8, and
    // return the result as a new LIGOTimeGPS.
    LIGOTimeGPS* __##NAME##__(REAL8 t) {
      return XLALGPSSetREAL8(new LIGOTimeGPS(), XLALGPSGetREAL8($self) OP t);
    }

    // Perform OP between a REAL8 and a LIGOTimeGPS, and
    // return the result as a new LIGOTimeGPS.
    LIGOTimeGPS* __r##NAME##__(REAL8 t) {
      return XLALGPSSetREAL8(new LIGOTimeGPS(), t OP XLALGPSGetREAL8($self));
    }

    // These operators are unused in Octave
    #if !defined(SWIGOCTAVE)

      // For some reason, in-place __operator__s must be declared both
      // %delobject and %newobject to work properly (see, e.g. SWIG's
      // wrapping of a C++ operator+= in Python). Note sure how exactly
      // this is different from not specifying any ownership %features...
      %delobject __i##NAME##__;
      %newobject __i##NAME##__;

      // Perform OP between two LIGOTimeGPSs, and
      // store the result on the left-hand side.
      LIGOTimeGPS* __i##NAME##__(LIGOTimeGPS* tgps) {
        return XLALINT8NSToGPS($self, XLALGPSToINT8NS($self) OP XLALGPSToINT8NS(tgps));
      }

      // Perform OP between a LIGOTimeGPS and an INT4, and
      // store the result on the left-hand side.
      LIGOTimeGPS* __i##NAME##__(INT4 t) {
        return XLALINT8NSToGPS($self, XLALGPSToINT8NS($self) OP (t * XLAL_BILLION_INT8));
      }

      // Perform OP between a LIGOTimeGPS and a REAL8, and
      // store the result on the left-hand side.
      LIGOTimeGPS* __i##NAME##__(REAL8 t) {
        return XLALGPSSetREAL8($self, XLALGPSGetREAL8($self) OP t);
      }

    #endif

  %enddef // swiglal_LIGOTimeGPS_additive_operator

  swiglal_LIGOTimeGPS_additive_operator(add, +)
  swiglal_LIGOTimeGPS_additive_operator(sub, -)

  // Multiplicative binary operators are generated by the following SWIG macro.
  // NAME is the name of the Python operator and OP is the C operator. These
  // always perform a floating-point OP on the GPS time converted to seconds.
  %define swiglal_LIGOTimeGPS_multiplicative_operator(NAME, OP)

    // Normal (and reverse) __operator__s must be declared %newobject
    // since they will allocate and return new LIGOTimeGPS instances
    %newobject __##NAME##__;
    %newobject __r##NAME##__;

    // Perform OP between two LIGOTimeGPSs, and
    // return the result as a new LIGOTimeGPS.
    LIGOTimeGPS* __##NAME##__(LIGOTimeGPS* tgps) {
      return XLALGPSSetREAL8(new LIGOTimeGPS(), XLALGPSGetREAL8($self) OP XLALGPSGetREAL8(tgps));
    }

    // Perform OP between a LIGOTimeGPS and a REAL8, and
    // return the result as a new LIGOTimeGPS.
    LIGOTimeGPS* __##NAME##__(REAL8 t) {
      return XLALGPSSetREAL8(new LIGOTimeGPS(), XLALGPSGetREAL8($self) OP t);
    }

    // Perform OP between a REAL8 and a LIGOTimeGPS, and
    // return the result as a new LIGOTimeGPS.
    LIGOTimeGPS* __r##NAME##__(REAL8 t) {
      return XLALGPSSetREAL8(new LIGOTimeGPS(), t OP XLALGPSGetREAL8($self));
    }

    // These operators are unused in Octave
    #if !defined(SWIGOCTAVE)

      // For some reason, in-place __operator__s must be declared both
      // %delobject and %newobject to work properly (see, e.g. SWIG's
      // wrapping of a C++ operator+= in Python). Note sure how exactly
      // this is different from simply passing the object unchanged...
      %delobject __i##NAME##__;
      %newobject __i##NAME##__;

      // Perform OP between two LIGOTimeGPSs, and
      // store the result on the left-hand side.
      LIGOTimeGPS* __i##NAME##__(LIGOTimeGPS* tgps) {
        return XLALGPSSetREAL8($self, XLALGPSGetREAL8($self) OP XLALGPSGetREAL8(tgps));
      }

      // Perform OP between a LIGOTimeGPS and a REAL8, and
      // store the result on the left-hand side.
      LIGOTimeGPS* __i##NAME##__(REAL8 t) {
        return XLALGPSSetREAL8($self, XLALGPSGetREAL8($self) OP t);
      }

    #endif

  %enddef // swiglal_LIGOTimeGPS_multiplicative_operator

  swiglal_LIGOTimeGPS_multiplicative_operator(mul, *)
  swiglal_LIGOTimeGPS_multiplicative_operator(div, /)

  // Comparison operators are generated by the following SWIG macro.
  // NAME is the name of the Python operator and OP is the C operator.
  // The correct comparison NAME is obtained by comparing the result
  // of the result of XLALGPSCmp() against zero using OP.
  %define swiglal_LIGOTimeGPS_comparison_operator(NAME, OP)

    // Compare two LIGOTimeGPSs
    bool __##NAME##__(LIGOTimeGPS *tgps) {
      return XLALGPSCmp($self, tgps) OP 0;
    }

    // Compare a LIGOTimeGPS and an INT4
    bool __##NAME##__(INT4 t) {
      LIGOTimeGPS tmp;
      return XLALGPSCmp($self, XLALGPSSet(&tmp, t, 0)) OP 0;
    }

    // Compare a LIGOTimeGPS and a REAL8
    bool __##NAME##__(REAL8 t) {
      LIGOTimeGPS tmp;
      return XLALGPSCmp($self, XLALGPSSetREAL8(&tmp, t)) OP 0;
    }

  %enddef

  swiglal_LIGOTimeGPS_comparison_operator(lt, < );
  swiglal_LIGOTimeGPS_comparison_operator(le, <=);
  swiglal_LIGOTimeGPS_comparison_operator(eq, ==);
  swiglal_LIGOTimeGPS_comparison_operator(ne, !=);
  swiglal_LIGOTimeGPS_comparison_operator(gt, > );
  swiglal_LIGOTimeGPS_comparison_operator(ge, >=);

  // Return a string representation of a LIGOTimeGPS. Because
  // XLALGPSToStr() allocates a new string using LAL memory,
  // we use %newobject to make SWIG use a 'newfree' typemap,
  // where we free the string; SWIG will have already copied it
  // to a native scripting-language string to return as output.
  %newobject __str__();
  %typemap(newfree) char* __str__ %{
    if ($1) {
      XLALFree($1);
    }
  %}
  char* __str__() {
    return XLALGPSToStr(NULL, $self);
  }

} // %extend LIGOTimeGPS

#endif // SWIG
